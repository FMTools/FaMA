<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1">
<link href='https://fonts.googleapis.com/css?family=Architects+Daughter'
	rel='stylesheet' type='text/css'>
<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css"
	media="screen">
<link rel="stylesheet" type="text/css"
	href="stylesheets/pygment_trac.css" media="screen">
<link rel="stylesheet" type="text/css" href="stylesheets/print.css"
	media="print">

<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<title>FAMA Framework</title>
</head>

<body>
	<header>
		<div class="inner">
			<h1>FAMA Framework</h1>
			<h2>FAMA Extensions Development Guide</h2>
			<a href="https://github.com/ISA-Research-Group/FaMA/tree/develop"
				class="button"><small>View project on</small>GitHub</a>
		</div>
	</header>

	<nav>
		<div class="inner">
			<a href="index.html"><img alt="Home" src="images/home.png"
				width="24" height="24" /></a>
		</div>
	</nav>

	<div id="content-wrapper">
		<div class="inner clearfix">
			<section id="main-content">
				<h3>
					<a name="create-fama-extension" class="anchor"
						href="create-fama-extension"><span
						class="octicon octicon-link"></span></a>4 Creating a New FAMA
					Extension
				</h3>

				<p>
					Before getting started, you will need to create a new plug-in
					project in your workspace and set it to use Maven. You can use the
					normal Eclipse process to create projects through the menu option
					<code>File » New » Project...</code>
				<ol>
					<li>Select the option <code>Plug-in</code> Project. Click <code>Next
							></code>.
					</li>
					<li>Give the project a name and select as path the path to
						where the other FAMA project were checked out. In this case we
						will be adding a new reasoner, Choco 3, as a new FAMA Extension so
						the project’s name is <code>Choco3Reasoner</code>. Click <code>Next
							></code>.
					</li>
					<li>Keep the option <code>Generate an Activator</code> ticked
						and in the <code>Activator</code> field set the activator’s
						canonical class name (full name including package) to the
						following naming pattern: <code>«2-letter country
							code».«University/Institution».«research group».«project
							name».osgi.Activator</code>. For the Choco 3 reasoner it is: <code>co.icesi.i2t.Choco3.osgi.Activator</code>.
						Click <code>Finish</code>. This class is used to connect the FAMA
						Extension to the FAMA Framework and will be edited once the FAMA
						Extension you develop is finished.
					</li>
					<li>Right click the newly created plug-in project and select
						the option <code>Configure » Convert to Maven Project</code>.
					</li>
					<li>A dialog will pop-up prompting to create a new Maven
						POM file. Fill out the form with the following information and
						click <code>Finish</code>. <pre>
Group Id: es.us.isa
Version: 1.0.0
Packaging: bundle
Name: «give the artifact a name». For example, for the Choco 3 reasoner it is: FaMa Choco 3 Reasoner.
Description: «give a description for the artifact». For example, for the Choco 3 reasoner it is: A reasoner for FaMa, based on Choco Solver v3. Built by I2T Research Group in collaboration with the FaMa Team.
						</pre>
					</li>
					<li>Maven should open the pom file. Switch to the <code>pom.xml</code>
						tab. <u>Note:</u> Eclipse may mark the line <code>&ltpackaging&gtbundle&lt/packaging&gt</code>
						in error. This will go away with the following steps.
					</li>
					<li>After the <code>&ltdescription&gt&lt/description&gt</code>
						element and before the closing <code>&lt/project&gt</code> tag
						paste the following <code>pom.xml</code> fragments:
						<ul>
							<li>Plug-in repositories <pre>
									<code>
&ltpluginRepositories&gt
	&ltpluginRepository&gt
		&ltid&gtmc-release&lt/id&gt
		&ltname&gtLocal Maven repository of releases&lt/name&gt
		&lturl&gthttp://mc-repo.googlecode.com/svn/maven2/releases&lt/url&gt
		&ltsnapshots&gt
			&ltenabled&gtfalse&lt/enabled&gt
		&lt/snapshots&gt
		&ltreleases&gt
			&ltenabled&gttrue&lt/enabled&gt
		&lt/releases&gt
	&lt/pluginRepository&gt
&lt/pluginRepositories&gt</code>
						</pre>
							</li>
							<li>Distribution management<pre>
									<code>
&ltdistributionManagement&gt
	&ltrepository&gt
		&ltid&gtisa.devel&lt/id&gt
		&ltname&gtISA archiva&lt/name&gt
		&lturl&gthttp://devel.isa.us.es/glassfish/archiva/repository/internal&lt/url&gt
	&lt/repository&gt
&lt/distributionManagement&gt

	</code>
						</pre>
							</li>
							<li>Repositories. Notice the last repository marked in
								black; it is specific to the development of the Choco 3
								reasoner. You should replace this repository with the ones
								concerning your particular FAMA extension if needed; otherwise
								you can safely remove those lines. <pre>
								<code>
&ltrepositories&gt
	&ltrepository&gt
		&ltid&gtisa.devel&lt/id&gt
		&ltname&gtISA archiva&lt/name&gt
		&lturl&gthttp://devel.isa.us.es/glassfish/archiva&lt/url&gt
		&ltlayout&gtdefault&lt/layout&gt
		&ltreleases&gt
			&ltenabled&gttrue&lt/enabled&gt
			&ltupdatePolicy&gtalways&lt/updatePolicy&gt
			&ltchecksumPolicy&gtwarn&lt/checksumPolicy&gt
		&lt/releases&gt
		&ltsnapshots&gt
			&ltenabled&gtfalse&lt/enabled&gt
			&ltupdatePolicy&gtnever&lt/updatePolicy&gt
			&ltchecksumPolicy&gtwarn&lt/checksumPolicy&gt
		&lt/snapshots&gt
	&lt/repository&gt</code>
	&ltrepository&gt
		&ltid&gtchoco.repos&lt/id&gt
		&lturl&gthttp://www.emn.fr/z-info/choco-repo/mvn/repository/&lt/url&gt
	&lt/repository&gt<code>
&lt/repositories&gt

								</code>
								</pre>
							</li>
							<li>Dependencies. Notice the first dependency marked in
								black; it is specific to the development of the Choco 3
								reasoner. You should replace this dependency with the ones
								concerning your particular FAMA extension, if needed; otherwise
								you can safely remove those lines. <u>Note</u>: The version
								numbers for dependencies may change, so be sure to update them
								when modifying any of the <code>pom.xml</code> files referenced
								in this guide.<pre>
								<code>
&lt;dependencies&gt;</code>
	&lt;dependency&gt;
		&lt;groupId&gt;choco&lt;/groupId&gt;
		&lt;artifactId&gt;choco-solver&lt;/artifactId&gt;
		&lt;version&gt;3.2.0&lt;/version&gt;
	&lt;/dependency&gt;<code>
	&lt;dependency&gt;
		&lt;groupId&gt;es.us.isa&lt;/groupId&gt;
		&lt;artifactId&gt;FaMaSDK&lt;/artifactId&gt;
		&lt;version&gt;1.2.0&lt;/version&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.osgi&lt;/groupId&gt;
		&lt;artifactId&gt;osgi_R4_core&lt;/artifactId&gt;
		&lt;version&gt;1.0&lt;/version&gt;
		&lt;scope&gt;provided&lt;/scope&gt;
		&lt;optional&gt;true&lt;/optional&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.osgi&lt;/groupId&gt;
		&lt;artifactId&gt;osgi_R4_compendium&lt;/artifactId&gt;
		&lt;version&gt;1.0&lt;/version&gt;
		&lt;scope&gt;provided&lt;/scope&gt;
		&lt;optional&gt;true&lt;/optional&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;
								</code>
								</pre>
							</li>
							<li>Build. Notice in the final lines of this fragment marked
								in black; they are specific to the development of the Choco 3
								reasoner. You should replace them according to your particular
								FAMA extension. <pre>
								<code>
&ltbuild&gt
	&ltdefaultGoal&gtinstall&lt/defaultGoal&gt
	&ltdirectory&gttarget&lt/directory&gt
	&ltsourceDirectory&gtsrc&lt/sourceDirectory&gt
	&ltoutputDirectory&gttarget/classes&lt/outputDirectory&gt
	&lttestSourceDirectory&gttest&lt/testSourceDirectory&gt
	&lttestOutputDirectory&gttarget/test-classes&lt/testOutputDirectory&gt
	&ltresources&gt
		&ltresource&gt
			&ltdirectory&gtresources&lt/directory&gt
		&lt/resource&gt
	&lt/resources&gt
	&lttestResources&gt
		&lttestResource&gt
			&ltdirectory&gtresources&lt/directory&gt
		&lt/testResource&gt
	&lt/testResources&gt
	&ltplugins&gt
		&ltplugin&gt
			&ltgroupId&gtorg.apache.maven.plugins&lt/groupId&gt
			&ltartifactId&gtmaven-compiler-plugin&lt/artifactId&gt
			&ltconfiguration&gt
				&ltsource&gt5&lt/source&gt
				&lttarget&gt5&lt/target&gt
			&lt/configuration&gt
		&lt/plugin&gt
		&ltplugin&gt
			&ltgroupId&gtorg.apache.maven.plugins&lt/groupId&gt
			&ltartifactId&gtmaven-jar-plugin&lt/artifactId&gt
			&ltconfiguration&gt
				&ltarchive&gt
					&lt!--&ltmanifestFile&gtMETA-INF/MANIFEST.MF&lt/manifestFile&gt --&gt
					&ltaddMavenDescriptor&gtfalse&lt/addMavenDescriptor&gt
					&lt!-- &ltmanifestEntries&gt &ltBuilt-By&gtI2T Research Group in collaboration with FaMa Team&lt/Built-By&gt &lt/manifestEntries&gt --&gt
				&lt/archive&gt
			&lt/configuration&gt
		&lt/plugin&gt
		&ltplugin&gt
			&ltgroupId&gtcom.mycila.maven-license-plugin&lt/groupId&gt
			&ltartifactId&gtmaven-license-plugin&lt/artifactId&gt
			&ltconfiguration&gt
				&ltexcludes&gt
					&ltexclude&gt**/**.xml/**&lt/exclude&gt
				&lt/excludes&gt
				&ltheader&gtcopyrightNotice.txt&lt/header&gt
			&lt/configuration&gt
			&ltexecutions&gt
			&lt/executions&gt
		&lt/plugin&gt
		&ltplugin&gt
			&ltgroupId&gtorg.apache.maven.plugins&lt/groupId&gt
			&ltartifactId&gtmaven-source-plugin&lt/artifactId&gt
			&ltexecutions&gt
				&ltexecution&gt
					&ltid&gtjar&lt/id&gt
					&ltphase&gtpackage&lt/phase&gt
					&ltgoals&gt
						&ltgoal&gtjar&lt/goal&gt
					&lt/goals&gt
					&ltconfiguration&gt
						&ltexcludeResources&gttrue&lt/excludeResources&gt
						&ltoverWriteReleases&gttrue&lt/overWriteReleases&gt
						&ltoverWriteSnapshots&gtfalse&lt/overWriteSnapshots&gt
						&ltoverWriteIfNewer&gttrue&lt/overWriteIfNewer&gt
					&lt/configuration&gt
				&lt/execution&gt
			&lt/executions&gt
		&lt/plugin&gt
		&ltplugin&gt
			&ltgroupId&gtorg.apache.felix&lt/groupId&gt
			&ltartifactId&gtmaven-bundle-plugin&lt/artifactId&gt
			&ltextensions&gttrue&lt/extensions&gt
			&ltversion&gt1.4.0&lt/version&gt
			&ltconfiguration&gt
				&ltinstructions&gt
					&ltBundle-SymbolicName&gt${pom.groupId}.${pom.artifactId}&lt/Bundle-SymbolicName&gt
					&ltBundle-Name&gt${pom.artifactId}&lt/Bundle-Name&gt
					</code>&ltBuilt-By&gtI2T Research Group in collaboration with FaMa Team&lt/Built-By&gt
					&ltExport-Package&gtco.icesi.i2t.*&lt/Export-Package&gt
					&ltBundle-Activator&gtco.icesi.i2t.Choco3.osgi.Activator
					&lt/Bundle-Activator&gt<code>
					&ltImport-Package&gtorg.osgi.framework,*;resolution:=optional
					&lt/Import-Package&gt
					</code>&ltBundle-ClassPath&gtlib/choco-parser-3.2.0-jar-with-dependencies.jar, .&lt/Bundle-ClassPath&gt<code>
				&lt/instructions&gt
			&lt/configuration&gt
		&lt/plugin&gt
	&lt/plugins&gt
&lt/build&gt

								</code>
								</pre>
							</li>
						</ul>
					</li>
					<li>Download any third-party libraries used in your FAMA
						extension and create a folder in your project to store them. The
						Choco 3 library may be downloaded from <a
						href="http://www.emn.fr/z-info/choco-repo/mvn/repository/choco/choco-parser/3.2.0/choco-parser-3.2.0-jar-with-dependencies.jar">here</a>
						<ul>
							<li>First you will need to create a new source folder. Right
								click over your FAMA extension project and select the option <code>New
									» Source folder</code>. Name it <code>resources</code>.
							</li>
							<li>Right click over the resources source folder and select
								the option <code>New » Folder</code>. Name this folder <code>lib</code>.
							</li>
							<li>Copy and paste the jar files of the third-party
								libraries into the lib folder.</li>
						</ul>
					</li>
				</ol>

				<h4>
					<a name="develop-new-reasoner" class="anchor"
						href="develop-new-reasoner"><span class="octicon octicon-link"></span></a>4.1
					Developing a New Reasoner
				</h4>

				<p>Every new reasoner added to the FAMA Framework should, at
					least, provide the implementation for handling simple feature
					models. If the solver used by the reasoner allows its use on
					extended feature models (e.g. attributed feature models), then an
					implementation for handling attributed feature models (currently
					the only extended feature model offered by the FAMA Framework) is
					strongly suggested. It is also suggested, if possible, to provide
					an implementation for the question ExplainErrors in both simple
					feature models and extended feature models. Follow these steps to
					develop a new reasoner. The development of the Choco 3 reasoner for
					handling simple feature models is provided as an example. It is
					suggested you use the Choco 3 reasoner source code to guide your
					development as it provides documentation and comments describing
					what the required methods should do and provide in return.</p>

				<ol>
					<li>Each implementation should comprise 2 packages: one to
						store the reasoner and abstract question classes, and another one
						to store the various question implementations. The packages should
						follow the naming pattern <code>«2-letter country
							code».«University/Institution».«research group».«project
							name».«feature model type»</code>. The second package’s name, the one
						holding the question implementations, should end with <code>questions</code>.
						For the Choco 3 reasoner we have the packages:
						<ul>
							<li>co.icesi.i2t.Choco3Reasoner.simple</li>
							<li>co.icesi.i2t.Choco3Reasoner.simple.questions</li>
							<li>co.icesi.i2t.Choco3Reasoner.attributed</li>
							<li>co.icesi.i2t.Choco3Reasoner.attributed.questions</li>
							<li>co.icesi.i2t.Choco3Reasoner4Exp.simple</li>
							<li>co.icesi.i2t.Choco3Reasoner4Exp.simple.questions</li>
							<li>co.icesi.i2t.Choco3Reasoner4Exp.attributed</li>
							<li>co.icesi.i2t.Choco3Reasoner4Exp.attributed.questions</li>
						</ul>
					</li>
					<li>For each implementation, the package with the naming
						pattern <code>«2-letter country
							code».«University/Institution».«research group».«project
							name».«feature model type»</code> will contain the reasoner’s class
						implementation extending from the abstract reasoner class
						corresponding to the feature model type it will handle. The names
						of these classes should follow the naming pattern <code>«name
							of reasoner»Reasoner</code> (using CamelCase). For example, for the
						simple feature model we created a class in the package <code>co.icesi.i2t.Choco3Reasoner.simple</code>
						and named it <code>Choco3Reasoner</code> that extends the <code>FeatureModelReasoner</code>
						abstract class provided by the <code>FaMaSDK</code> project in the
						package <code>es.us.isa.FAMA.Reasoner</code>. <br /> This
						reasoner class should define the necessary methods to create a
						representation of the feature model, as described in Subsections
						2.3 and 2.4, that the reasoner can use to be able to provide
						specific information about it. The required methods to implement
						are:
						<ul>
							<li><code>addFeature</code>: Creates a representation of the
								given feature in the reasoner.</li>
							<li><code>addRoot</code>: Marks the given feature as the
								root feature and ensures that it is present in every product.</li>
							<li><code>addMandatory</code>: Creates a representation of a
								mandatory relationship between the given parent and child
								features.</li>
							<li><code>addOptional</code>: Creates a representation of an
								optional relationship between the given parent and child
								features.</li>
							<li><code>addExcludes</code>: Creates a representation of an
								excludes relationship between the given origin and destination
								features.</li>
							<li><code>addRequires</code>: Creates a representation of a
								requires relationship between the given origin and destination
								features.</li>
							<li><code>addSet</code>: Creates a representation of a set
								relationship between the given parent and its children features.</li>
							<li><code>applyStagedConfiguration</code>: Applies a staged
								configuration to the representation of the feature model in the
								reasoner.</li>
							<li><code>unapplyStagedConfiguration</code>: Removes the
								staged configuration applied with the previous method from the
								representation of the feature model in the reasoner.</li>
							<li><code>ask</code>: Provides an answer to a given question
								about specific information of the feature model, for example the
								number of products that can be derived from a given feature
								model. A question represents an analysis operation, like the one
								in the example, over a given feature model.</li>
						</ul> <u>Note:</u> For the reasoners in the packages of ExplainErrors
						(4Exp) you must inherit from the respective implementation’s
						reasoner created previously in this step and not from the abstract
						reasoner class provided by the <code>FaMaSDK</code> project.
					</li>
					<li>Also, the package from <a
						href="section4.html#develop-new-reasoner">step 2</a> will also
						contain an abstract class implementing the interface <code>Question</code>
						provided by the <code>FaMaSDK</code> project in the package <code>es.us.isa.FAMA.Reasoner</code>.
						This class will define the required behavior that every question
						should implement. It is suggested that this abstract class defines
						a three-phased answering process to provide an answer. The phases
						should be: pre-answer, answer, and post-answer. The pre-answer
						phase should prepare the reasoner and other resources needed prior
						to answering the question. The answer phase should answer the
						question using the given reasoner. And, finally, the post-answer
						phase should release any resources associated with answering the
						question. The name of this class should follow the naming pattern
						<code>«name of reasoner»Question</code> (using CamelCase). For
						example, for the simple feature model we created a new class in
						the package <code>co.icesi.i2t.Choco3Reasoner.simple</code> and
						named it <code>Choco3Question</code> that implements the <code>Question</code>
						interface.
					</li>
					<li>The package with the naming pattern <code>«2-letter
							country code».«University/Institution».«research group».«project
							name»</code> will contain the implementation for the performance result
						of the implemented reasoner. The names of this class should follow
						the naming pattern <code>«name of
							reasoner»PerformanceResult</code> (using CamelCase). For example, for
						the Choco 3 reasoner we created a class in the package <code>co.icesi.i2t.Choco3Reasoner</code>
						and named it <code>Choco3PerformanceResult</code> that extends the
						<code>PerformanceResult</code> abstract class provided by the <code>Benchmark</code>
						project in the package <code>es.us.isa.FAMA.Benchmarking</code>.
						This class should retrieve measures recorded from the reasoner
						while solving a question. The following measures are retrieved for
						the Choco 3 reasoner:
						<ul>
							<li><code>Node count</code>: Gives the amount of nodes in
								the search tree. A node is possible value assignment to a
								variable. The search tree represents all possible value
								assignments to all the variables in the CSP.</li>
							<li><code>Current depth</code>: Gives the current depth of
								the search tree. It corresponds to the number of variables.</li>
							<li><code>Backtrack count</code>: Gives the amount of jumps
								to the last variable when a conflict with some other value
								arises.</li>
							<li><code>Time count</code>: Gives the time, in seconds,
								taken by the reasoner to solve the CSP. It includes constraint
								propagation time.</li>
						</ul>
					</li>
					<li>The package with the naming pattern <code>«2-letter
							country code».«University/Institution».«research group».«project
							name».«feature model type».questions</code> will contain the
						implementation for the questions supported by the implemented
						reasoner. The names of the classes implementing the questions
						should follow the naming pattern <code>«name of
							reasoner»«name of question»</code> (using CamelCase). The next
						subsection will describe how to create a new question. For example
						the questions implemented in the Choco 3 reasoner for simple
						feature models are: (the questions marked with a <code>*</code>
						use the default implementation provided by the <code>FaMaSDK</code>
						project)
						<ul>
							<li><code>Core features*</code>: This question is answered
								by calculating the features that are present in every product
								that can be derived from the feature model with the specified
								constraints. This operation gives the opposite result of the
								variant features operation.</li>
							<li><code>Variant features*</code>: This operation
								calculates the features that are not present on every product
								that can be derived from the feature model with the specified
								constraints. This operation gives the opposite result of the
								core features operation.</li>
							<li><code>Dead features*</code>: This question is answered
								by calculating the features that are not present in any product
								that can be derived from the feature model with the specified
								constraints. A feature is dead if it cannot appear in any
								product due to wrong definitions of cross-tree constraints.</li>
							<li><code>Unique features*</code>: This question is answered
								by the features that are unique to a product that can be derived
								from the feature model with the specified constraints.</li>
							<li><code>Number of products</code>: This question is
								answered by calculating the number of products that can be
								derived from the feature model with the specified constraints.</li>
							<li><code>One product</code>: This question is answered by
								calculating a valid product of a feature model that can be
								derived from the feature model with the specified constraints.</li>
							<li><code>Valid product*</code>: This question is answered
								by determining if a product is valid or not for a given feature
								model represented by a CSP. A product is a valid product if it
								is a solution of the CSP.</li>
							<li><code>Products</code>: This question is answered by
								calculating all valid products that can be derived from the
								feature model with the specified constraints.</li>
							<li><code>Valid configuration*</code>: This question is
								answered by analyzing if a configuration is valid or not. A
								configuration is a non-finished product that can need more
								features to be a valid product.</li>
							<li><code>Commonality*</code>: This question is answered by
								calculating the percentage of products represented by the
								feature model including the input configuration.

								<table class="fraction" align="center" cellpadding="0"
									cellspacing="0">
									<tr>
										<td rowspan="2" nowrap="nowrap"><i>Commonality</i> =</td>
										<td nowrap="nowrap"><i>number of products after
												applying a configuration</i></td>
									</tr>
									<tr>
										<td class="upper_line"><i>number of products</i></td>
									</tr>
								</table></li>
							<li><code>Variability*</code>: This operation calculates the
								variability degree of a feature model. The variability degree is
								the ratio between the number of products and 2^n where n is the
								number of features considered. In particular, 2^n is the
								potential number of products represented by a feature model
								assuming that any combination of features is allowed. The root
								and non-leaf features are often not considered.
								<table class="fraction" align="center" cellpadding="0"
									cellspacing="0">
									<tr>
										<td rowspan="2" nowrap="nowrap"><i>Variability</i> =</td>
										<td nowrap="nowrap"><i>number of products</i></td>
									</tr>
									<tr>
										<td class="upper_line">2<sup>n</sup>
										</td>
									</tr>
								</table> Where <code>n</code> is the number of features considered.</li>
							<li><code>Homogeneity*</code>:This question is answered by
								calculating the degree of homogeneity for the products that can
								be derived from the feature model with the specified
								constraints. Homogeneity is related with the number of unique
								features among products. The more unique features, the less
								homogeneous the feature model is.
								<table class="fraction" align="center" cellpadding="0"
									cellspacing="0">
									<tr>
										<td rowspan="2" nowrap="nowrap"><i>Homogeneity</i> =</td>
										<td rowspan="2" nowrap="nowrap">1 –</td>
										<td nowrap="nowrap"><i>number of unique features</i></td>
									</tr>
									<tr>
										<td class="upper_line"><i>number of products</i></td>
									</tr>
								</table></li>
							<li><code>Valid</code>: This question is answered by
								analyzing if a CSP representing a feature model is valid. A CSP
								is valid if after propagating the specified constraints at least
								one solution is found.</li>
							<li><code>Detect errors*</code>: This question is answered
								by looking for errors on a feature model.</li>
							<li><code>Explain invalid product</code>: This question
								provides as answer the options to repair an invalid product for
								a given feature model.</li>
							<li><code>Valid configuration errors</code>: This question
								is answered by looking for explanations for errors in
								configurations of a given feature model.</li>
						</ul> Some questions have been deprecated in FAMA Framework 1.2 and
						therefore are not implemented in the Choco 3 reasoner for simple
						feature models. These questions are:
						<ul>
							<li><code>Filter</code>: This question takes as input a
								feature model and a partial configuration, and provides as
								answer the set of products that can be derived from the model
								and include the features from the input configuration. This
								question has been deprecated as this operation was included into
								the existing reasoners, and all additional reasoners must
								provide native support, through the methods <code>applyStagedConfiguration</code>
								and <code>unapplyStagedConfiguration</code>.</li>
							<li><code>Set</code>: This question answers a list of given
								questions. A question can be added to the list by using the
								method <code>addQuestion</code>. This question has been
								deprecated.</li>
						</ul> Some questions were not implemented:
						<ul>
							<li><code>Explain errors in feature model diagram</code>:
								When a feature model has errors, this question is answered by
								looking for explanations for those errors.</li>
							<li><code>Valid configuration errors AW (Another Way)</code>:
								This question is the same as valid configuration errors but
								provides a more efficient implementation.</li>
						</ul>
					</li>
				</ol>

				<h4>
					<a name="develop-new-question" class="anchor"
						href="develop-new-question"><span class="octicon octicon-link"></span></a>4.2
					Developing a new question to be answered by the reasoner
				</h4>

				<p>The previous questions are the default questions a reasoner
					should be able to answer, but it should not be limited to this set.
					New questions may require a complete implementation to be answered
					or they can use or compose the solutions of already existing
					questions.
				<ol>
					<li>The new question should extend the abstract class created
						in step 3 <a href="section4.html#develop-new-reasoner">here</a>.
					</li>
					<li>Provide the implementation for the three phases of the
						answering process. If you require to use or compose the solutions
						of already existing questions do not call the answer phase
						directly. You must use the ask method provided by the reasoner
						class implemented in step 2 <a
						href="section4.html#develop-new-reasoner">here</a>, as it will
						ensure that the three-phased answering process is carried out
						completely for each question.
					</li>
				</ol>

				</p>

				<h4>
					<a name="connect-fama-extension" class="anchor"
						href="connect-fama-extension"><span
						class="octicon octicon-link"></span></a>4.3 Connecting the new FAMA
					Extension to the FAMA Framework
				</h4>

				<p>
					FAMA Extensions are loaded dynamically based on availability. The
					concept behind dynamic loading is to associate implementations to
					the available interfaces. Extensions can be loaded using either
					OSGi or a Java class loader. Remember the
					<code>Activator</code>
					class from step 3 <a href="section4.html#create-fama-extension">here</a>?
					This class’s responsibility is to load the FAMA Extension using
					OSGi and make it available to be used by the FAMA Framework. The
					SPL Core of the FAMA Framework, implemented by the project
					<code>FaMaSDK</code>
					, has an
					<code>Activator</code>
					class too. In this case the
					<code>FaMaSDK</code>
					’s Activator is used to load all the FAMA Extensions available.
				</p>

				<p>
					Your FAMA Extension’s
					<code>Activator</code>
					class should define two methods:
					<code>start</code>
					and
					<code>stop</code>
					. The
					<code>start</code>
					method is called when the FAMA Extension is activated and should
					register the services you implemented in it. The
					<code>stop</code>
					method should unregister such services. For example, for the Choco
					3 reasoner the start method creates an instance for the reasoner’s
					implementation that handles simple feature models as well as for
					each of the supported questions, and then registers them as
					services in the OSGi context so they can be available to
					<code>FaMaSDK</code>
					. The stop method unregisters the questions and the reasoner from
					the OSGi context.
				</p>

				<p>
					If OSGi is not available or not used, the Extension can be loaded
					using a Java class loader, which works in a similar way as OSGi but
					services are not registered through a Java class. Depending on the
					type of extension (e.g. reasoner, metamodel) it would be required
					to have more than one loader configuration file. The FAMA loader
					configuration file is named
					<code>FaMaConfig.xml</code>
					and is found in the project
					<code>FaMa-Docs</code>
					. For a new reasoner extension, a
					<code>&ltreasoner /&gt</code>
					tag should be added in-between the
					<code>&ltquestionTrader&gt&lt/questionTrader&gt</code>
					tags. For the Choco 3 reasoner implementation we inserted the tag
					in the following listing.
				</p>
				<pre>
					<code>
&ltreasoner id="Choco3" 
file="lib/Choco3Reasoner-1.0.0.jar" 
class="co.icesi.i2t.Choco3Reasoner.simple.Choco3Reasoner" /&gt
					</code>
				</pre>

				<p>
					Particularly for a reasoner extension, questions need to be loaded
					independently. The reasoner project should contain its own loader
					configuration file, in the
					<code>resources</code>
					folder, with interface-class pair tags. For a reasoner extension
					the loader configuration file needs to follow the format shown in
					the following listing.
				</p>
				<pre>
					<code>
&ltreasoner&gt
	&ltquestion interface="«interface canonical name»" class="implementation class’s canonical name"/&gt
&lt/reasoner&gt
					</code>
				</pre>
				</p>

				<p>The Choco 3 reasoner loader configuration file for simple
					feature models looks like the fragment in the following listing.</p>
				<pre>
					<code>
&ltreasoner&gt
	&ltquestion interface="es.us.isa.FAMA.Reasoner.questions.CommonalityQuestion" class="co.icesi.i2t.Choco3Reasoner.simple.questions.Choco3CommonalityQuestion"/&gt
...
&lt/reasoner&gt

					</code>
				</pre>
			</section>

			<aside id="sidebar">
				<a href="files/FAMA-Framework-Extensions-Development-Guide.pdf"
					class="button"> <small>Download Guide</small> .pdf file
				</a>
				<p class="repo-owner">
					The <a href="https://github.com/ISA-Research-Group/FaMA">FAMA
						Framework</a> is maintained by the <a href="http://www.isa.us.es">ISA
						Research Group</a>.
				</p>

				<p>The first version of this guide was developed by Andrés Paz
					in the context of the FAMA Framework project and the SHIFT project
					during a research scholarship at the University of Seville
					(Seville, Spain), partly funded by Banco Santander under the
					program Becas Iberoamérica Jóvenes Profesores Investigadores
					Colombia and Colciencias (Colombian Administrative Department of
					Science, Technology and Innovation).</p>
				<p>
					<img alt="Creative Commons Attribution 4.0 International License"
						src="images/cc-license.png">This work is licensed under the
					Creative Commons Attribution 4.0 International License. To view a
					copy of this license, visit <a
						href="http://creativecommons.org/licenses/by/4.0/">CreativeCommons.org</a>.
				</p>
			</aside>
		</div>
	</div>

	<footer>
		<div class="inner">
			<p>
				This page was generated by <a href="https://pages.github.com">GitHub
					Pages</a> using a variation of the Architect theme by <a
					href="https://twitter.com/jasonlong">Jason Long</a>.
			</p>
		</div>
	</footer>


</body>
</html>