<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="viewport"
	content="width=device-width, initial-scale=1, maximum-scale=1">
<link href='https://fonts.googleapis.com/css?family=Architects+Daughter'
	rel='stylesheet' type='text/css'>
<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css"
	media="screen">
<link rel="stylesheet" type="text/css"
	href="stylesheets/pygment_trac.css" media="screen">
<link rel="stylesheet" type="text/css" href="stylesheets/print.css"
	media="print">

<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<title>FAMA Framework</title>
</head>

<body>
	<header>
		<div class="inner">
			<h1>FAMA Framework</h1>
			<h2>FAMA Extensions Development Guide</h2>
			<a href="https://github.com/ISA-Research-Group/FaMA/tree/develop"
				class="button"><small>View project on</small>GitHub</a>
		</div>
	</header>

	<nav>
		<div class="inner">
			<a href="index.html"><img alt="Home" src="images/home.png"
				width="24" height="24" /></a>
		</div>
	</nav>

	<div id="content-wrapper">
		<div class="inner clearfix">
			<section id="main-content">
				<h3>
					<a id="overview-fama-fw" class="anchor" href="overview-fama-fw"><span
						class="octicon octicon-link"></span></a>2 Overview of the FAMA
					Framework
				</h3>

				<p>
					<a href="http://www.isa.us.es/fama/?FaMa_Framework">FAMA</a>
					(FeAture Model Analyzer) is an open source Java framework under
					LGPLv3 license for the automated analysis of feature models. It
					provides useful information extracted from these models, such as
					the number of products that can be derived from them, and possible
					errors they may have.
				</p>
				<p>FAMA is developed as OSGi plug-ins, which allow an easier
					development and assembly. The framework has three layers, as shown
					in Figure 1, namely public interfaces, SPL Core and FAMA
					Extensions. The SPL Core provides the necessary services to allow
					interoperation between the extension modules but keeping them
					uncoupled. The extensions layer is composed of various modules,
					such as metamodels, operations and reasoners to name a few.</p>
				<img border="0" src="images/fama-architecture.png"
					alt="FAMA Framework Architecture" />

				<h4>
					<a id="overview-feature-models" class="anchor"
						href="overview-feature-models"><span
						class="octicon octicon-link"></span></a>2.1 Feature models
				</h4>

				<p>A feature model is a hierarchical tree structure representing
					all the products that can be derived from a Software Product Line
					(SPL) in terms of “features”. Features are distinctive
					characteristics of a software system. Every feature model comprises
					features and the relationships among them. The first feature in the
					feature model, called the root feature, is used to identify the SPL
					and should always be present in every product.</p>
				<p>The remaining features emerge from this root feature in a
					hierarchical tree structure. Relationships between features may be
					of two types. On the one hand, parental relationships, i.e. between
					a parent feature and its child features. Parental relationships can
					be categorized as mandatory, optional or set. On the other hand,
					non-parental relationships, also known as cross-tree constraints.
					The most common cross-tree constraints are requires and excludes.
					All these features are defined as follows:</p>
				<dl>
					<dt>Mandatory:</dt>
					<dd>A mandatory relationship states that if a parent feature
						is present in a product its child feature must be present too.</dd>
					<dt>Optional:</dt>
					<dd>An optional relationship states that if a parent feature
						is present in a product its child feature may or may not be
						present.</dd>
					<dt>Set:</dt>
					<dd>
						A set of child features has a set relation with their parent when
						a number of them can be included in the products in which its
						parent feature appears. The amount of child features that may be
						included is given by the relation cardinality. The relation
						cardinality is expressed as a range of values
						<code>[x,y]</code>
						, where
						<code>x ≤ y</code>
						and
						<code>y ≤ number of child features</code>
						. Two special cases of set relations can be identified:
						Alternative and Or relations.
					</dd>
					<dt>Alternative:</dt>
					<dd>
						A set of child features have an Alternative relation with their
						parent when only one child can be present when its parent feature
						is present in the product. In this case the relation cardinality
						can be expressed as
						<code>[0,1]</code>
						.
					</dd>
					<dt>Or:</dt>
					<dd>
						A set of child features have an Or relation with their parent when
						one or more of them can be present when its parent feature is
						present in the product. In this case the relation cardinality can
						be expressed as
						<code>[0,n]</code>
						, where
						<code>n</code>
						is the number of child features.
					</dd>
					<dt>Requires:</dt>
					<dd>
						A requires relationship is a cross tree constraint that states
						that if feature
						<code>A</code>
						requires feature
						<code>B</code>
						then if feature
						<code>A</code>
						is present in a product, feature
						<code>B</code>
						must be present too.
					</dd>
					<dt>Excludes:</dt>
					<dd>
						An excludes relationship is a cross tree constraint that states
						that if feature
						<code>A</code>
						excludes feature
						<code>B</code>
						then features
						<code>A</code>
						and
						<code>B</code>
						can not be present at the same time in a product.
					</dd>
				</dl>
				<p>
					Feature models can be extended, if necessary, to include additional
					information about its features. These extended feature models are
					commonly referenced as extended, advanced or attributed feature
					models. Extended feature models enable more complex constraints
					among features and attributes, for example <i>“If attribute A
						of feature F is lower than a value X, then feature T can not be
						part of the product”</i>.
				</p>

				<h4>
					<a id="overview-fama-extensions" class="anchor"
						href="overview-fama-extensions"><span
						class="octicon octicon-link"></span></a>2.2 Overview of the FAMA
					Extensions Layer
				</h4>

				<p>
					Since the FAMA Framework is component-oriented, it allows for its
					easy extension to functionality and feature model support through
					new components that are known as FAMA Extensions. This FAMA
					Extensions will live in the FAMA Extensions Layer. Currently the
					FAMA Framework includes several FAMA Extensions that provide
					support for creating feature models conforming to various feature
					metamodels, operations over feature models, reasoners, and model
					transformations. Metamodel extensions provide different approaches
					to represent a feature model; supported metamodels are <a
						href="http://gsd.uwaterloo.ca/fmp">Czarnecki’s
						cardinality-based feature models</a>, <a
						href="http://www.moskitt.org/eng/que-es-moskitt/">Moskitt</a> and
					an own FAMA metamodel. Operation extensions specify concerns that
					arise when handling feature models and that need to be solved, such
					as what products can be derived from a given feature model or are
					there any errors present in the feature model. Operation extensions
					are used closely with reasoner extensions.
				</p>
				<p>A reasoner is meant to execute the operations over feature
					models to obtain required information or properties from it. There
					are different techniques to perform these operations, and the
					constraint satisfaction problem technique is one of them. Reasoner
					extensions are usually implemented to use a specific technique, for
					example through out this guide we will be developing a new reasoner
					to support the analysis of feature models represented through
					constraint satisfaction problems; following sections will explain
					more about what constraint satisfactions problems are and how they
					are used to build a representation of feature models. Anyone can
					create a FAMA Extension that extends the framework in one of these
					aspects or create one for an entirely new purpose. For more detail
					on the FAMA Extensions available please refer to [Jesús García
					Galán. FaMa Framework (MSc. Thesis). Escuela Técnica Superior de
					Ingeniería Informática, Departamento de Lenguajes y Sistemas
					Informáticos, Universidad de Sevilla. 2009.].</p>

				<h4>
					<a id="overview-csp" class="anchor" href="overview-csp"><span
						class="octicon octicon-link"></span></a>2.3 Overview of a Constraint
					Satisfaction Problem representation of feature models
				</h4>

				<p>
					A Constraint Satisfaction Problem (CSP) is defined as a three-tuple
					composed of a set of problem variables, a set of domain values for
					each of the variables, and a set of constraints over those
					variables that restrict the values they can take. A CSP is solved
					by the assignment of a value to every variable in its domain
					through search and propagation in such way that all constraints are
					simultaneously satisfied. A feature model can be mapped to a CSP.
					The features from the feature model will be represented as
					variables with a domain equivalent to its specific cardinality. The
					representations for the relationships are as follows (more detail
					about these representations can be found <a
						href="http://dx.doi.org/10.1016/j.is.2010.01.001">here</a>):
				</p>
				<dl>
					<dt>Mandatory:</dt>
					<dd>
						A mandatory relation between a parent feature and its child can be
						represented with the logical expression parent
						<code>present ⇔ child present</code>
						.
					</dd>
					<dt>Optional:</dt>
					<dd>
						An optional relation between a parent feature and its child can be
						represented with the logical expression
						<code>parent not present ⇒ child not present</code>
						.
					</dd>
					<dt>Set:</dt>
					<dd>
						A set constraint between a parent feature and its children with
						cardinality [x,y] can be represented with the logical expression
						<code>(parent present ⇒ x ≤ ∑children present ≤ y) ∧
							(parent not present ⇒ children not present)</code>
						, equivalent to an if-then-else. Both the Alternative and Or cases
						are handled by this expression.
					</dd>
					<dt>Requires:</dt>
					<dd>
						A Requires relation between an origin feature and its destination
						can be represented with the logical expression
						<code>origin present ⇒ destination present</code>
						.
					</dd>
					<dt>Excludes:</dt>
					<dd>
						An Excludes relation between an origin feature and its destination
						can be represented with the logical expression
						<code>¬(origin present ∧ destination present)</code>
						that can also be expressed as
						<code>origin present ⇒ destination not present</code>
						.
					</dd>
				</dl>
				<p>A product that can be derived from the feature model
					represented as a CSP is, thus, one of the possible solutions to the
					CSP.</p>

				<h4>
					<a id="overview-choco" class="anchor" href="overview-choco"><span
						class="octicon octicon-link"></span></a>2.4 Overview of Choco and
					Choco 3
				</h4>

				<p>In order to solve CSPs we can use one of the many tools that
					have been developed for this purpose. Since the FAMA Framework is
					built on top of Java and all extensions are encouraged to be built
					using Java we have chosen to work with Choco for the development of
					our new reasoner. Choco is an open source Java library developed
					for constraint satisfaction problems (CSP) and constraint
					programming (CP). It is meant to be used for teaching and research
					purposes, although several industrial companies use it.</p>
				<p>
					<a
						href="http://www.emn.fr/z-info/choco-solver/index.php?page=choco-3">Choco
						3</a> is the newest and current release to date of Choco, however, it
					breaks all backwards compatibility with previous versions of the
					tool as it was completely rewritten from the ground up. This new
					version of Choco integrates various types of variables (e.g.
					integer, Boolean, set, graph, real), various constraints (natively
					supports explained contraints) (e.g. classical arithmetic
					constraints, alldifferent, count, nvalues), various search
					strategies (e.g. first fail, smallest, impact-based,
					activity-based), and an explanation-based engine. However, the
					Choco 3 library no longer provides native support for biconditional
					expressions, so, for example, to represent the mandatory
					relationship with Choco 3 an equivalent expression needs to be
					used, sucha as
					<code>(parent present ⇒ child present) ∧ (child present ⇒
						parent present)</code>
					.
				</p>
			</section>

			<aside id="sidebar">
				<a href="files/FAMA-Framework-Extensions-Development-Guide.pdf"
					class="button"> <small>Download Guide</small> .pdf file
				</a>
				<p class="repo-owner">
					The <a href="https://github.com/ISA-Research-Group/FaMA">FAMA
						Framework</a> is maintained by the <a href="http://www.isa.us.es">ISA
						Research Group</a>.
				</p>

				<p>The first version of this guide was developed by Andrés Paz
					in the context of the FAMA Framework project and the SHIFT project
					during a research scholarship at the University of Seville
					(Seville, Spain), partly funded by Banco Santander under the
					program Becas Iberoamérica Jóvenes Profesores Investigadores
					Colombia and Colciencias (Colombian Administrative Department of
					Science, Technology and Innovation).</p>
				<p>
					<img alt="Creative Commons Attribution 4.0 International License"
						src="images/cc-license.png">This work is licensed under the
					Creative Commons Attribution 4.0 International License. To view a
					copy of this license, visit <a
						href="http://creativecommons.org/licenses/by/4.0/">CreativeCommons.org</a>.
				</p>
			</aside>
		</div>
	</div>

	<footer>
		<div class="inner">
			<p>
				This page was generated by <a href="https://pages.github.com">GitHub
					Pages</a> using a variation of the Architect theme by <a
					href="https://twitter.com/jasonlong">Jason Long</a>.
			</p>
		</div>
	</footer>


</body>
</html>